package CXN::DepthUtil ;

use CXN::Table  ;
use CXN::PersistOB  ; 
use URI::Escape ;
#use FileHandle ;

sub new {
    my $class = shift                                             ; 
    my $self = {}                                                 ;
    $self -> {'cgi'}{'vars'} = shift                           ;
    bless ($self, $class)                                         ;
    return ( $self )
}

sub mk_table {
    my $self = shift                                              ;
    my $thing = shift                                             ; 

    $self -> descend( $thing, 'dont stop' )                       ;

    if (  $self -> { 'search' } ) {
       $self -> search_arrs ( $self -> { 'search' })              ;
    }

    $self -> fmt_arr                                              ;

    my $table = new CXN::Table                                     ;
    $ret = $table -> gen_tables( $self -> {arr_stack} )            ;
    return $ret 
}

sub descend {
  my $self = shift                                                ;
  my $thing = shift                                               ;
  my $instr = shift                                                ;

  my $ref_thing = ref $thing ;
   if ( $ref_thing eq 'HASH' ) {   
                 #if it is a hash push each key into the tmp arrays
                 #and descend into the hash
      my @thing_keys = sort keys %$thing                               ;
      #print join (' ',@thing_keys)."\n"                     ;
      foreach $key ( @thing_keys ) {
        if (( $key !~ /<STOP\/*>/i ) 
           or ( $instr eq 'dont stop' )
           or ( defined $self -> {'search'} )) {
          push(@{$self -> {tmparr}}, $key)                          ;
          my $depth_arr = [ @{$self -> {depth_arr}}, @{$self -> {tmparr}} ] ; 
          my $cell_string 
            = $self -> cell_string ( 
                 #$key, $depth_arr, undef, 'test', 'passwd' ); 
                 $key, $depth_arr, undef, 'test' ); 
          push(@{$self -> {pr_tmparr}}, $cell_string)               ;
          $self -> descend($thing -> {$key});
        }
        else { 
          my @pr_arr = @{$self -> {pr_tmparr}}                        ;
          #push(@{$self -> {tmparr}}, $key)                          ;
          my $depth_arr = [ @{$self -> {depth_arr}}, @{$self -> {tmparr}},$key ] ; 
          my $cell_string
            = $self -> cell_string ( 
                 $key." <img src=/images/handright.gif border=0 align=right>", $depth_arr, undef, 'test' );               
          push(@pr_arr, $cell_string)                                    ;
          push(@{$self -> {arr_stack}}, \@pr_arr)                     ;
        }
      }
   }
   elsif ( $ref_thing eq 'ARRAY' ) {
                 #if it is an array then you are at the data
                 #make perm print array from tmp print array 
                 #and push values into print array
      my @pr_arr = @{$self -> {pr_tmparr}}                        ;
      $cell_str = join("<BR><BR>", @$thing)                ;
      push(@pr_arr, $cell_str)                                    ;
      push(@{$self -> {arr_stack}}, \@pr_arr)                     ;
   }
   else {  
                 #if it is an array then you are at the data
                 # it must be a scalar, same as array
      my @pr_arr = @{$self -> {pr_tmparr}}                        ;
      push(@pr_arr, $thing )                                      ;
      push(@{$self -> {arr_stack}}, \@pr_arr)                     ;
   }
  pop(@{$self -> {tmparr}})                                       ;
  pop(@{$self -> {pr_tmparr}})
 #}
} #descend

sub cell_string {
   my $self = shift ;
   my ( $value, 
        $depth_arr, 
        $db, 
        $depth_stop, 
        $hidden_struct, 
        $graphics_arr, 
        $font_arr,
        $secret, 
                      ) = @_                                      ;
   my $cell_string = '<a href=/cgi-bin/Depth/?'                   ;
   my $depth_string = join (' ', @$depth_arr )                    ;
   $depth_string = uri_escape ( $depth_string )                   ;
   $cell_string .= 'depth='. $depth_string                        ;
   $cell_string .= '&db='.$db  if $db                             ;
   $cell_string .= '&secret='.$secret if $secret                  ;
   $cell_string .= $hidden_struct if $hidden_struct               ;
   $cell_string .= '>'.$value.'</a>'                                  ;
   return $cell_string
}

sub full_cell_string {
   my $self = shift ;
   my ( $value, 
        $script,
        $path,
        $hidden_struct, 
        $graphics_arr, 
        $font_arr 
                        ) = @_                                      ;
   my $cell_string = '<a href='                                     ;
   if ( defined $script ) 
          { $cell_string .= '/'.$script.'/' }
   elsif ( defined $self -> {'script'} )  
          { $cell_string .= '/'.$self -> {script}.'/' } 
   elsif ( defined $ENV{'SCRIPT_NAME'} ) 
          { $cell_string .= '/'.$ENV{'SCRIPT_NAME'}.'/' } 
   elsif ( defined $vars{'script'} ) 
          { $cell_string .= '/'.$vars{'script'}.'/' } 
   $cell_string .= '?'                                              ;
   if ( defined $hidden_struct ) {
 # need a new name for hidden
   $hidden_struct = $self -> _uri_escape($hidden_struct)             ;
   $cell_string .= 'hidden='. $hidden_struct                        ;
   }
   return $cell_string.'>'.$value.'</a>'  ;
}

sub _uri_escape {
   my $self = shift ;
   my $thing = shift ;
   if (( ref $thing eq 'ARRAY' ) or ( ref $thing eq 'HASH' )) {
     $thing = &_serialize($thing) } 
   return uri_escape($thing) 
}

sub _serialize {
   my $self = shift ;
   my $thing = shift ;
   return $self -> {persist} -> serialize($thing) ; 
}
   
sub fmt_arr {
   my $self = shift                                         ;
   my $arr                                                  ;
   foreach $arr (@{$self -> {arr_stack}}) {
     my @sav_arr = @$arr                                    ;
     my $last_arr = $self -> {last_arr}                     ;
     my $cnt = 0                                            ;
     $arr_len = $#$arr                                       ;
     my $off_flag ;
     foreach ( @$arr ) {
       if ( $last_arr -> [$cnt] eq $arr -> [$cnt] ) {
         $arr -> [$cnt] = undef if $off_flag ne 'yes'        ;
       } 
       else { $off_flag = 'yes' }
       $cnt++                                               ;
     }
     @{$self -> {last_arr}} = @sav_arr                      ;
     $arr_num = @$arr                                       ;
   }
   push( @{$self -> {out_stack}}, $arr)  
}

sub search {
   my $self = shift ;
   my $search = shift;
   $self -> {'search'} = $search if $search ne '' ;
          # This is to prevent null searches matching everything
}

sub search_arrs {
   my $self = shift ;
   my $search = shift ;
   my $search_hit_stack   ;
   foreach $arr (@{$self -> {arr_stack}}) {
     my @search_arr;
     if ( grep /$search/i, @$arr ) {
       my $cnt = 0 ;
       while ( $cnt < $#$arr ) {
         $$arr[$cnt] =~ 
         s/(>)([^<>]*)($search)([^<>]*)(<)/$1$2<font color=orangered>$3<\/font>$4$5/ig ;
         $cnt++
       }
       $$arr[$#$arr] =~ s/($search)/<font color=orangered>$1<\/font>/gi 
         if $$arr[$#$arr] !~ /href/i ;
       push( @$search_hit_stack, $arr)
     }
   }
   $self -> {arr_stack} = $search_hit_stack   ;
}

sub depth2uri {
    my $self = shift                                            ;
    my $depth_str = shift                                       ;
    return uri_escape($depth_str)
}

sub DESTROY {
    my $self = shift ;
}

1;
